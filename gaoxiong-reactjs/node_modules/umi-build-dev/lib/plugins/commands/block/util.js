"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.printBlocks = printBlocks;
exports.selectInstallBlockArgs = selectInstallBlockArgs;
exports.getDefaultBlockList = getDefaultBlockList;
exports.gitUpdate = gitUpdate;
exports.gitClone = gitClone;
exports.installDependencies = installDependencies;

var _chalk = _interopRequireDefault(require("chalk"));

var _path = require("path");

var _fs = require("fs");

var _execa = _interopRequireDefault(require("execa"));

var _assert = _interopRequireDefault(require("assert"));

var _ora = _interopRequireDefault(require("ora"));

var _gitUrlParse = _interopRequireDefault(require("git-url-parse"));

var _terminalLink = _interopRequireDefault(require("terminal-link"));

var _inquirer = _interopRequireDefault(require("inquirer"));

var _getBlockGenerator = require("./getBlockGenerator");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/**
 * åˆ¤æ–­æ˜¯ä¸æ˜¯ä¸€ä¸ª gitmodules çš„ä»“åº“
 */
const isSubmodule = templateTmpDirPath => (0, _fs.existsSync)((0, _path.join)(templateTmpDirPath, '.gitmodules'));

const genBlockName = name => name.match(/[A-Z]?[a-z]+|[0-9]+/g).map(p => p.toLowerCase()).join('/');
/**
 * å°†åŒºå—è½¬åŒ–ä¸º inquirer èƒ½ç”¨çš„æ•°ç»„
 * @param {*} blocks
 * @returns {[
 *  name:string;
 *  value:string;
 *  key:string;
 * ]} blockArray
 */


function printBlocks(blocks, hasLink) {
  const blockArray = [];

  const loopBlocks = (blocks, parentPath = '') => {
    blocks.forEach(block => {
      if (block.type === 'block') {
        const blockName = (0, _path.join)(parentPath, block.path);
        let name = `ğŸ“¦  ${_chalk.default.cyan(blockName)}  `;

        if (hasLink) {
          // é“¾æ¥åˆ° pro çš„é¢„è§ˆç•Œé¢
          // AccountCenter -> account/center
          const previewPath = genBlockName(blockName);
          const link = (0, _terminalLink.default)('é¢„è§ˆ', `https://preview.pro.ant.design/${previewPath}`); // å¢åŠ ä¸€ä¸ªé¢„è§ˆçš„ç•Œé¢

          name += link;
        }

        blockArray.push({
          name,
          value: blockName,
          key: blockName
        });
      }

      if (block.type === 'dir') {
        return loopBlocks(block.blocks, block.path);
      }

      return null;
    });
  };

  loopBlocks(blocks);
  return blockArray;
}
/**
 * äº¤äº’å‹åŒºå—é€‰æ‹©
 * - é€‰æ‹©åŒºå—å
 * - è¾“å…¥è·¯å¾„
 * - é€‰æ‹©æ˜¯å¦è½¬åŒ– js
 * @param {[
 *  name:string;
 *  value:string;
 *  key:string;
 * ]} blockArray
 * @returns Promise<{args}>
 */


function selectInstallBlockArgs(_x) {
  return _selectInstallBlockArgs.apply(this, arguments);
}
/**
 * è·å–åŒºå—åˆ—è¡¨ï¼Œé»˜è®¤ä¼šä»  http://blocks.umijs.org/api/blocks æ‹‰
 * å¦‚æœé…ç½® defaultGitUrl ï¼Œä¼šä» defaultGitUrl å»æ‰¾
 * @param {*} _
 * @param {*} blockConfig
 * @param {*} addBlock
 */


function _selectInstallBlockArgs() {
  _selectInstallBlockArgs = _asyncToGenerator(function* (blockArray) {
    return new Promise(
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(function* (resolve) {
        let locale = false;

        const _ref2 = yield _inquirer.default.prompt([{
          type: 'list',
          name: 'block',
          message: `â›°  è¯·é€‰æ‹©åŒºå—ï¼ˆå…± ${blockArray.length} ä¸ª )`,
          choices: blockArray
        }, {
          type: 'input',
          name: 'path',
          message: 'ğŸ—  è¯·è¾“å…¥è¾“å‡ºå®‰è£…åŒºå—çš„è·¯å¾„'
        }, {
          type: 'confirm',
          name: 'js',
          message: 'ğŸ¤”  å°† Typescript åŒºå—è½¬åŒ–ä¸º js?',
          default: false
        }, {
          type: 'confirm',
          name: 'uni18n',
          message: 'ğŸŒ  åˆ é™¤ i18n ä»£ç ? ',
          default: false
        }]),
              block = _ref2.block,
              path = _ref2.path,
              js = _ref2.js,
              uni18n = _ref2.uni18n;

        if (uni18n) {
          const _ref3 = yield _inquirer.default.prompt([{
            type: 'input',
            name: 'region',
            message: 'ğŸŒ  è¯·è¾“å…¥ä½ çš„é€‰æ‹©çš„è¯­è¨€? ',
            default: 'zh-CN'
          }]),
                region = _ref3.region;

          locale = region;
        }

        const blockPath = path || genBlockName(block);
        resolve({
          _: ['add', block],
          path: blockPath,
          js,
          uni18n: locale
        });
      });

      return function (_x9) {
        return _ref.apply(this, arguments);
      };
    }());
  });
  return _selectInstallBlockArgs.apply(this, arguments);
}

function getDefaultBlockList(_x2) {
  return _getDefaultBlockList.apply(this, arguments);
}
/**
 * clone ä¸‹æ¥çš„ git ä¼šç¼“å­˜ã€‚è¿™ä¸ªæ–¹æ³•å¯ä»¥æ›´æ–°ç¼“å­˜
 * @param {*} ctx
 * @param {*} spinner
 */


function _getDefaultBlockList() {
  _getDefaultBlockList = _asyncToGenerator(function* (_, blockConfig = {}, addBlock) {
    const spinner = (0, _ora.default)();

    const got = require('got');

    let blockArray = [];
    const defaultGitUrl = blockConfig.defaultGitUrl;
    spinner.start('ğŸš£  fetch block list'); // å¦‚æœå­˜åœ¨ defaultGitUrl çš„é…ç½®ï¼Œå°±ä» defaultGitUrl é…ç½®ä¸­æ‹¿åŒºå—åˆ—è¡¨

    if (defaultGitUrl) {
      const ignoreFile = ['_scripts', 'tests'];

      const _GitUrlParse = (0, _gitUrlParse.default)(defaultGitUrl),
            name = _GitUrlParse.name,
            owner = _GitUrlParse.owner;

      spinner.succeed();
      spinner.start(`ğŸ”  find block list form ${_chalk.default.yellow(defaultGitUrl)}`); // ä¸€ä¸ª github çš„ api,å¯ä»¥è·å¾—æ–‡ä»¶æ ‘

      const _ref4 = yield got(`https://api.github.com/repos/${owner}/${name}/git/trees/master`),
            body = _ref4.body;

      const files = JSON.parse(body).tree.filter(file => file.type === 'tree' && !ignoreFile.includes(file.path)).map(({
        path
      }) => ({
        type: 'block',
        path
      }));
      blockArray = printBlocks(files, 'link');
    } else {
      const _ref5 = yield got(`http://blocks.umijs.org/api/blocks`),
            body = _ref5.body;

      const _JSON$parse = JSON.parse(body),
            status = _JSON$parse.status,
            error = _JSON$parse.error,
            data = _JSON$parse.data;

      if (status === 'success') {
        blockArray = printBlocks(data);
      } else {
        throw new Error(error);
      }
    }

    spinner.succeed();

    if (blockArray.length > 0) {
      const args = yield selectInstallBlockArgs(blockArray);
      return addBlock(args);
    }

    return new Error('No block found');
  });
  return _getDefaultBlockList.apply(this, arguments);
}

function gitUpdate(_x3, _x4) {
  return _gitUpdate.apply(this, arguments);
}
/**
 * å…‹éš†åŒºå—çš„åœ°å€
 * @param {*} ctx
 * @param {*} spinner
 */


function _gitUpdate() {
  _gitUpdate = _asyncToGenerator(function* (ctx, spinner) {
    spinner.start('ğŸš’  Git fetch');

    try {
      yield (0, _execa.default)(`git`, ['fetch'], {
        cwd: ctx.templateTmpDirPath
      });
    } catch (e) {
      spinner.fail();
      throw new Error(e);
    }

    spinner.succeed();
    spinner.start(`ğŸš›  Git checkout ${ctx.branch}`);

    try {
      yield (0, _execa.default)(`git`, ['checkout', ctx.branch], {
        cwd: ctx.templateTmpDirPath
      });
    } catch (e) {
      spinner.fail();
      throw new Error(e);
    }

    spinner.succeed();
    spinner.start('ğŸš€  Git pull');

    try {
      yield (0, _execa.default)(`git`, [`pull`], {
        cwd: ctx.templateTmpDirPath
      }); // å¦‚æœæ˜¯ git pull ä¹‹åæœ‰äº†
      // git module åªèƒ½é€šè¿‡è¿™ç§åŠæ³•æ¥åˆå§‹åŒ–ä¸€ä¸‹

      if (isSubmodule(ctx.templateTmpDirPath)) {
        // ç»“æŸ  git pull çš„ spinner
        spinner.succeed(); //å¦‚æœæ˜¯åˆ†æ”¯åˆ‡æ¢è¿‡æ¥ï¼Œå¯èƒ½æ²¡æœ‰åˆå§‹åŒ–ï¼Œåˆå§‹åŒ–ä¸€ä¸‹

        yield (0, _execa.default)(`git`, ['submodule', 'init'], {
          cwd: ctx.templateTmpDirPath,
          env: process.env
        });
        spinner.start(`ğŸ‘€ update submodule`);
        yield (0, _execa.default)(`git`, ['submodule', 'update', '--recursive'], {
          cwd: ctx.templateTmpDirPath
        });
      }
    } catch (e) {
      spinner.fail();
      throw new Error(e);
    }

    spinner.succeed();
  });
  return _gitUpdate.apply(this, arguments);
}

function gitClone(_x5, _x6) {
  return _gitClone.apply(this, arguments);
}
/**
 * å®‰è£…ä¾èµ–åŒ…
 * - è·å–é¡¹ç›®è·¯å¾„
 * - é€’å½’è·å¾—ä¾èµ–é¡¹ã€‚
 * - è°ƒç”¨ npm æ¥åˆå¹¶å®‰è£…ä¾èµ–é¡¹
 * @param {*} param0
 * @param {*} ctx
 */


function _gitClone() {
  _gitClone = _asyncToGenerator(function* (ctx, spinner) {
    spinner.start(`ğŸ”  clone git repo from ${ctx.repo}`);

    try {
      yield (0, _execa.default)(`git`, [`clone`, ctx.repo, ctx.id, `--single-branch`, `--recurse-submodules`, `-b`, ctx.branch], {
        cwd: ctx.blocksTempPath,
        env: process.env
      });
    } catch (e) {
      spinner.fail();
      throw new Error(e);
    }

    spinner.succeed();
  });
  return _gitClone.apply(this, arguments);
}

function installDependencies(_x7, _x8) {
  return _installDependencies.apply(this, arguments);
}

function _installDependencies() {
  _installDependencies = _asyncToGenerator(function* ({
    npmClient,
    registry,
    applyPlugins,
    paths,
    debug,
    dryRun,
    spinner
  }, ctx) {
    // read project package.json
    const projectPkgPath = applyPlugins('_modifyBlockPackageJSONPath', {
      initialValue: (0, _path.join)(paths.cwd, 'package.json')
    });
    (0, _assert.default)((0, _fs.existsSync)(projectPkgPath), `No package.json found in your project`); // eslint-disable-next-line

    const projectPkg = require(projectPkgPath); // get _mock.js dependencie


    let devDependencies = {};
    const mockFilePath = (0, _path.join)(ctx.sourcePath, 'src/_mock.js');

    if ((0, _fs.existsSync)(mockFilePath)) {
      devDependencies = (0, _getBlockGenerator.getMockDependencies)((0, _fs.readFileSync)(mockFilePath, 'utf-8'), ctx.pkg);
    }

    const allBlockDependencies = (0, _getBlockGenerator.getAllBlockDependencies)(ctx.templateTmpDirPath, ctx.pkg); // æ„é€  _modifyBlockDependencies çš„æ‰§è¡Œå‚æ•°

    const initialValue = (0, _getBlockGenerator.dependenciesConflictCheck)(allBlockDependencies, projectPkg.dependencies, devDependencies, _objectSpread({}, projectPkg.devDependencies, projectPkg.dependencies)); // get confilict dependencies and lack dependencies

    const _applyPlugins = applyPlugins('_modifyBlockDependencies', {
      initialValue
    }),
          conflicts = _applyPlugins.conflicts,
          lacks = _applyPlugins.lacks,
          devConflicts = _applyPlugins.devConflicts,
          devLacks = _applyPlugins.devLacks;

    debug(`conflictDeps ${conflicts}, lackDeps ${lacks}`, `devConflictDeps ${devConflicts}, devLackDeps ${devLacks}`); // find confilict dependencies throw error

    const allConflicts = [...conflicts, ...devConflicts];
    const ErrorInfo = allConflicts.map(info => {
      return `* ${info[0]}: ${info[2]}(your project) not compatible with ${info[1]}(block)`;
    }).join('\n');

    if (allConflicts.length) {
      throw new Error(`find dependencies conflict between block and your project:${ErrorInfo}`);
    } // find lack confilict, auto install


    if (dryRun) {
      debug('dryRun is true, skip install dependencies');
    } else {
      if (lacks.length) {
        const deps = lacks.map(dep => `${dep[0]}@${dep[1]}`);
        spinner.start(`ğŸ“¦  Install additional dependencies ${deps.join(',')} with ${npmClient} --registry ${registry}`);

        try {
          let npmArgs = npmClient.includes('yarn') ? ['add'] : ['install'];
          npmArgs = [...npmArgs, ...deps, `--registry=${registry}`]; // å®‰è£…åŒºå—çš„æ—¶å€™ä¸éœ€è¦å®‰è£… puppeteer, å› ä¸º yarn ä¼šå…¨é‡å®‰è£…ä¸€æ¬¡æ‰€æœ‰ä¾èµ–ã€‚
          // åŠ ä¸ªç¯å¢ƒå˜é‡è§„é¿ä¸€ä¸‹

          yield (0, _execa.default)(npmClient, npmClient.includes('yarn') ? npmArgs : [...npmArgs, '--save'], {
            cwd: (0, _path.dirname)(projectPkgPath),
            env: _objectSpread({}, process.env, {
              // ref  https://github.com/GoogleChrome/puppeteer/blob/411347cd7bb03edacf0854760712d32b0d9ba68f/docs/api.md#environment-variables
              PUPPETEER_SKIP_CHROMIUM_DOWNLOAD: true
            })
          });
        } catch (e) {
          spinner.fail();
          throw new Error(e);
        }

        spinner.succeed();
      }

      if (devLacks.length) {
        // need skip devDependency which already install in dependencies
        const devDeps = devLacks.filter(dep => !lacks.find(item => item[0] === dep[0])).map(dep => `${dep[0]}@${dep[1]}`);
        spinner.start(`Install additional devDependencies ${devDeps.join(',')} with ${npmClient}  --registry ${registry}`);

        try {
          let npmArgs = npmClient.includes('yarn') ? ['add'] : ['install'];
          npmArgs = [...npmArgs, ...devDeps, `--registry=${registry}`];
          yield (0, _execa.default)(npmClient, npmClient.includes('yarn') ? npmArgs : [...npmArgs, '--save-dev'], {
            cwd: (0, _path.dirname)(projectPkgPath)
          });
        } catch (e) {
          spinner.fail();
          throw new Error(e);
        }

        spinner.succeed();
      }
    }
  });
  return _installDependencies.apply(this, arguments);
}